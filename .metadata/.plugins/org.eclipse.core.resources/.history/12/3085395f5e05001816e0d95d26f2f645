package Dota2Parser.Dota2Parser;

import java.io.File;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import skadistats.clarity.Clarity;
import skadistats.clarity.model.Entity;
import skadistats.clarity.model.FieldPath;
import skadistats.clarity.processor.entities.Entities;
import skadistats.clarity.processor.entities.OnEntityCreated;
import skadistats.clarity.processor.entities.OnEntityUpdated;
import skadistats.clarity.processor.entities.UsesEntities;
import skadistats.clarity.processor.reader.OnTickStart;
import skadistats.clarity.processor.runner.Context;
import skadistats.clarity.processor.runner.SimpleRunner;
import skadistats.clarity.source.MappedFileSource;
import skadistats.clarity.source.Source;
import skadistats.clarity.wire.common.proto.Demo.CDemoFileInfo;

@UsesEntities
public class App
{    
    private PrintWriter heroWriter;
    private PrintWriter heroSelectionWriter;
    private PrintWriter cameraWriter;
    private PrintWriter stateWriter;
    
    private Hero hero;
    private Camera camera;
    private Selection selection;
    private GameState state;
    
    private boolean isHero(Entity e)
    {
        return e.getDtClass().getDtName().startsWith("CDOTA_Unit_Hero");
    }
    
    private boolean isGameRules(Entity e)
    {
    	return e.getDtClass().getDtName().equals("CDOTAGamerulesProxy");
    }
    
    private boolean isPlayer(Entity e)
    {
    	return e.getDtClass().getDtName().equals("CDOTAPlayer");
    }
    
    private void initializeSelection(Entity e)
    {
    	if (selection == null)
    	{
    		selection = new Selection(e);
    	}
    }
    
    private void initializeHero(Entity e)
    {
        if (hero == null)
        {
        	hero = new Hero(e);            
        }
    }
    
    private void initializeCamera(Entity e)
    {
        if (camera == null)
        {
        	camera = new Camera(e);
        }
    }
    
    private void initializeState(Entity e)
    {
        if (state == null)
        {
        	state = new GameState(e);
        }
    }
    
    @OnEntityCreated
    public void onCreated(Context ctx, Entity e)
    {
        if (!isHero(e))
        {
            return;
        }
        initializeHero(e);
        
        handleHero(ctx, e, null, 0, true);
    }

    @OnEntityUpdated
    public void onUpdated(Context ctx, Entity e, FieldPath[] updatedPaths, int updateCount)
    {
        if (isHero(e))
        {
            handleHero(ctx, e, updatedPaths, updateCount, false);
        }
        else if (isGameRules(e))
        {
        	handleHeroSelection(ctx, e, updatedPaths, updateCount);
        	handleGameState(ctx, e, updatedPaths, updateCount);
        }
        else if (isPlayer(e))
        {
        	handleCamera(ctx, e, updatedPaths, updateCount);
        }
    }
    
    private void handleCamera(Context ctx, Entity e, FieldPath[] updatedPaths, int updateCount)
    {
    	initializeCamera(e);
    	
    	boolean updatePosition = false;
        for (int i = 0; i < updateCount; i++)
        {
            if (camera.isPosition(updatedPaths[i]))
            {
                updatePosition = true;
                break;
            }
        }
        
        if (updatePosition)
        {
        	heroWriter.format("%d [POSITION] %s %s %s %s\n", ctx.getTick(),
                    e.getPropertyForFieldPath(camera.playerID),
                    e.getPropertyForFieldPath(camera.x),
                    e.getPropertyForFieldPath(camera.y),
                    e.getPropertyForFieldPath(camera.z));
        	heroWriter.flush();
        }
    }
    
    private void handleGameState(Context ctx, Entity e, FieldPath[] updatedPaths, int updateCount)
    {
    	initializeState(e);
    	
    	boolean updateState = false;
        for (int i = 0; i < updateCount; i++)
        {
            if (state.isState(updatedPaths[i]))
            {
            	updateState = true;
                break;
            }
        }
        
        if (updateState)
        {
        	heroWriter.format("%d [STATE] %s\n", ctx.getTick(),
                    e.getPropertyForFieldPath(state.state));
        	heroWriter.flush();
        }
    }
    
    private void handleHeroSelection(Context ctx, Entity e, FieldPath[] updatedPaths, int updateCount)
    {
    	initializeSelection(e);
    	
    	boolean updateSelection[] = new boolean[10];
        boolean updateBan[] = new boolean[12];
        for (int i = 0; i < updateCount; i++)
        {
        	for (int j = 0; j < 10; j++)
        	{
        		if (updatedPaths[i].equals(selection.selections[j]))
                {
        			updateSelection[j] = true;
                }
        	}
            
        	for (int j = 0; j < 12; j++)
        	{
        		if (updatedPaths[i].equals(selection.bans[j]))
                {
        			updateBan[j] = true;
                }
        	}
        }        
        
        for (int i = 0; i < 10; i++)
        {
        	if (updateSelection[i])
        	{
        		heroWriter.format("%d [SELECT] %s\n",
        				ctx.getTick(),
        				e.getPropertyForFieldPath(selection.selections[i]));
        		heroWriter.flush();
        	}
        }
    	
        for (int i = 0; i < 12; i++)
        {
        	if (updateBan[i])
        	{
        		heroWriter.format("%d [BAN] %s\n",
        				ctx.getTick(),
        				e.getPropertyForFieldPath(selection.bans[i]));
        		heroWriter.flush();
        	}
        }
    }
    
    private void handleHero(Context ctx, Entity e, FieldPath[] updatedPaths, int updateCount, boolean forceUpdate)
    {        
        boolean updatePosition = false;
        boolean updateHealth = false;
        for (int i = 0; i < updateCount; i++)
        {
            if (hero.isPosition(updatedPaths[i]))
            {
                updatePosition = true;
            }
            if (hero.isHealth(updatedPaths[i]))
            {
                updateHealth = true;
            }
        }
        
        if (updatePosition || forceUpdate)
        {
        	heroWriter.format("%d [POSITION] %s %s %s %s\n", ctx.getTick(),
                    e.getDtClass().getDtName(),
                    e.getPropertyForFieldPath(hero.x),
                    e.getPropertyForFieldPath(hero.y),
                    e.getPropertyForFieldPath(hero.z));
        	heroWriter.flush();
        }
        if (updateHealth || forceUpdate)
        {
        	heroWriter.format("%d [HEALTH] %s %s\n", ctx.getTick(),
            		e.getDtClass().getDtName(),
            		e.getPropertyForFieldPath(hero.health));
        	heroWriter.flush();
        }
    }
    
    public void run(String[] args) throws Exception
    {
    	CDemoFileInfo info = Clarity.infoForFile(args[0]);
        File infoFile = new File(args[1] + "/info.txt");
        PrintWriter w = new PrintWriter(infoFile);
        w.write(info.toString());
        w.close();
        
        File heroFile = new File(args[1] + "/hero.txt");
        File selectionFile = new File(args[1] + "/selection.txt");
        File cameraFile = new File(args[1] + "/camera.txt");
        File stateFile = new File(args[1] + "/state.txt");
        
        heroWriter = new PrintWriter(heroFile);
        heroSelectionWriter = new PrintWriter(selectionFile);
        cameraWriter = new PrintWriter(cameraFile);
        stateWriter = new PrintWriter(stateFile);
        
        Source source = new MappedFileSource(args[0]);
        new SimpleRunner(source).runWith(this);
        
        heroWriter.close();
        heroSelectionWriter.close();
        cameraWriter.close();
        stateWriter.close();
    }

    public static void main(String[] args) throws Exception
    {
    	// args[0] is location of .dem file
    	// args[1] is location to store files
    	
        // 30 ticks per second
        new App().run(args);
    }

}